import z from "zod";

const DefaultFieldsSchema = z.object({
  id: z.string(),
  orgId: z.string(),
  createdBy: z.string().nullable(),
  updatedBy: z.string().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

const SocialPlatform = z.enum([
  "github",
  "twitter",
  "facebook",
  "linkedin",
  "instagram",
  "youtube",
  "tiktok",
  "other",
]);

const SocialSchema = z
  .object({
    platform: SocialPlatform.optional().or(z.literal("")),
    url: z.string().optional(),
    doctorPersonalDetailId: z.string(),
  })
  .merge(DefaultFieldsSchema);

const LanguageSpoken = z
  .object({
    langCode: z.string(),
    doctorPersonalDetailId: z.string(),
  })
  .merge(DefaultFieldsSchema);

export const DoctorPersonalDetailsSchema = z
  .object({
    title: z.string(),
    fullName: z.string(),
    nationality: z.string(),
    dateOfBirth: z.date(),
    gender: z.string(),
    mobileNumber: z.string(),
    email: z.string().email(),
    alternativeMobileNumber: z.string().nullable(),
    alternativeEmail: z.string().nullable(),
    doctorId: z.string(),
    languagesSpoken: z.array(LanguageSpoken),
    socialAccounts: z.array(SocialSchema),
    kycAddress: z
      .object({
        careOf: z.string(),
        addressLine: z.string(),
        city: z.string(),
        district: z.string(),
        state: z.string(),
        pincode: z.string(),
        doctorPersonalDetailId: z.string(),
      })
      .merge(DefaultFieldsSchema)
      .nullable(),
    communicationAddress: z
      .object({
        sameAsKyc: z.boolean(),
        careOf: z.string().nullable(),
        addressLine: z.string().nullable(),
        city: z.string().nullable(),
        district: z.string().nullable(),
        state: z.string().nullable(),
        pincode: z.string().nullable(),
        doctorPersonalDetailId: z.string(),
      })
      .merge(DefaultFieldsSchema)
      .nullable(),
  })
  .merge(DefaultFieldsSchema);
export type TDoctorPersonalDetails = z.infer<
  typeof DoctorPersonalDetailsSchema
>;

export type TDoctorProfileDetailsCreateData = {
  doctorData: {
    orgId: string;
    userId: string;
    doctorId: string;
  };
  profileData: TDoctorPersonalDetails;
};

const qualificationSchema = z
  .object({
    countryOfQualification: z.string(),
    degreeName: z.string(),
    country: z.string(),
    state: z.string(),
    college: z.string(),
    university: z.string(),
    passingMonth: z.string(),
    passingYear: z.string(),
    nameMatchesAadhaar: z.boolean(),
    doctorQualificationId: z.string(),
  })
  .merge(DefaultFieldsSchema);

export const DoctorQualificationSchema = z
  .object({
    systemOfMedicine: z.string(),
    category: z.string(),
    councilName: z.string(),
    registrationNumber: z.string(),
    dateOfFirstRegistration: z.date(),
    registrationType: z.enum(["permanent", "renewal"]),
    registrationValidDate: z.date().nullable(),
    nameMatchesAadhaar: z.boolean(),
    doctorId: z.string(),
    qualifications: z.array(qualificationSchema),
  })
  .merge(DefaultFieldsSchema)
  .refine(
    (data) =>
      data.registrationType === "permanent" ||
      (data.registrationType === "renewal" && data.registrationValidDate),
    {
      message: "Registration valid date is required for renewal type",
      path: ["registrationValidDate"],
    }
  );
export type TDoctorQualifications = z.infer<typeof DoctorQualificationSchema>;

export const DoctorWorkingFacilityDetailSchema = z
  .object({
    facilityId: z.string(),
    facilityStatus: z.boolean(),
    facilityName: z.string(),
    address: z.string(),
    state: z.string(),
    district: z.string(),
    type: z.string(),
    department: z.string(),
    designation: z.string(),
    doctorWorkId: z.string(),
  })
  .merge(DefaultFieldsSchema);
export type TDoctorWorkingFacilityDetail = z.infer<
  typeof DoctorWorkingFacilityDetailSchema
>;

const workStatus = ["government", "private", "both"] as const;

export const DoctorWorkDetailsSchema = z
  .object({
    currentlyWorking: z.boolean(),
    experience: z.string(),
    reasonForNotWorking: z.string().nullable(),
    otherReason: z.string().nullable(),
    natureOfWork: z.string().nullable(),
    teleConsultationURL: z.string().nullable(),
    workStatus: z.enum(workStatus).nullable(),
    governmentCategory: z.enum(["central", "state"]).nullable(),
    centralGovernment: z.string().nullable(),
    doctorId: z.string(),

    workingFacilities: z.array(DoctorWorkingFacilityDetailSchema),

    about: z.string(),
  })
  .merge(DefaultFieldsSchema)
  .superRefine((data, ctx) => {
    // 1️⃣ When not currently working → must specify reason
    if (!data.currentlyWorking && !data.reasonForNotWorking) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Reason for not working is required",
        path: ["reasonForNotWorking"],
      });
    }

    // 2️⃣ When reason = "other" → require 'otherReason'
    if (
      !data.currentlyWorking &&
      data.reasonForNotWorking === "other" &&
      !data.otherReason
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Please specify the reason for not working",
        path: ["otherReason"],
      });
    }

    // 3️⃣ When currently working → require key work fields
    if (data.currentlyWorking) {
      if (!data.natureOfWork) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Nature of work is required",
          path: ["natureOfWork"],
        });
      }
      if (!data.workStatus) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Work status is required",
          path: ["workStatus"],
        });
      }
    }

    // 4️⃣ Government category validation
    if (data.workStatus === "government" || data.workStatus === "both") {
      if (!data.governmentCategory) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Government category is required",
          path: ["governmentCategory"],
        });
      }

      if (data.governmentCategory === "central" && !data.centralGovernment) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Central government department is required",
          path: ["centralGovernment"],
        });
      }
    }

    // 5️⃣ When currently working → require at least one facility
    if (data.currentlyWorking) {
      if (!data.workingFacilities || data.workingFacilities.length === 0) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "At least one working facility detail is required",
          path: ["workingFacilityDetails"],
        });
      }
    }

    // 6️⃣ When not working → workingFacilityDetails must be empty or ignored
    if (!data.currentlyWorking && data.workingFacilities?.length) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          "Working facility details should be empty when not currently working",
        path: ["workingFacilityDetails"],
      });
    }
  });

export type TDoctorWorkDetails = z.infer<typeof DoctorWorkDetailsSchema>;

export const DoctorConcentSchema = z
  .object({
    isAgreeToShowDetailsPublic: z.boolean().optional(),
    name: z.boolean(),
    systemOfMedicine: z.boolean(),
    qualification: z.boolean(),
    experience: z.boolean(),
    showToPublic: z.boolean().optional(),
    email: z.boolean().optional(),
    contactNumber: z.boolean().optional(),
    placeOfWork: z.boolean().optional(),
    profilePicture: z.boolean().optional(),
    languageSpoken: z.boolean().optional(),
    workStatus: z.boolean().optional(),
    teleConsultation: z.boolean().optional(),
    isDeclearedToCreateDoctorAccount: z.boolean(),
    doctorId: z.string(),
  })
  .merge(DefaultFieldsSchema);
export type TDoctorConcent = z.infer<typeof DoctorConcentSchema>;

export const DoctorSchema = z
  .object({
    userId: z.string().nullable(),
    doctorId: z.number(),
    isCompleted: z.boolean(),
    registrationNumber: z.string().nullable(),
    registrationProvider: z.string().nullable(),
    personal: DoctorPersonalDetailsSchema.nullable(),
    qualification: DoctorQualificationSchema.nullable(),
    workDetail: DoctorWorkDetailsSchema.nullable(),
    concent: DoctorConcentSchema.nullable(),
  })
  .merge(DefaultFieldsSchema);
export type TDoctor = z.infer<typeof DoctorSchema>;

export const DoctorDatasSchema = z.object({
  doctorDatas: z.array(DoctorSchema),
  total: z.number(),
});
export type TDoctorDatas = z.infer<typeof DoctorDatasSchema>;

export const DoctorInitialProfileSchema = z
  .object({
    userId: z.string().nullable(),
    doctorId: z.number(),
    isCompleted: z.boolean(),
  })
  .merge(DefaultFieldsSchema);
export type TDoctorInitialProfile = z.infer<typeof DoctorInitialProfileSchema>;

const AddressSchema = z.object({
  careOf: z.string(),
  addressLine: z.string(),
  city: z.string(),
  district: z.string(),
  state: z.string(),
  pincode: z.string(),
});

export const createOrUpdateDoctorProfileDetailSchema =
  DoctorPersonalDetailsSchema.omit({
    kycAddress: true,
    communicationAddress: true,
    languagesSpoken: true,
    socialAccounts: true,
    id: true,
    createdAt: true,
    createdBy: true,
    updatedAt: true,
    updatedBy: true,
  }).merge(
    z.object({
      id: z.string().nullable(),
      operationBy: z.string(),
      languagesSpoken: z.array(z.string()),
      socialAccounts: z
        .array(
          z.object({
            id: z.string(),
            platform: SocialPlatform.optional().or(z.literal("")),
            url: z.string().optional(),
          })
        )
        .optional(),
      kycAddress: AddressSchema,
      communicationAddress: z.object({
        sameAsKyc: z.boolean(),
        careOf: z.string().optional(),
        addressLine: z.string().optional(),
        city: z.string().optional(),
        district: z.string().optional(),
        state: z.string().optional(),
        pincode: z.string().optional(),
      }),
    })
  );
export type TCreateOrUpdateDoctorProfileDetail = z.infer<
  typeof createOrUpdateDoctorProfileDetailSchema
>;
